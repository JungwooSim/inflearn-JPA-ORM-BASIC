### 상속관계 매핑
- 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

#### 슈퍼타입, 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
- <b>각 테이블로 변환 -> 조인 전략</b>
  - 장점
    - 테이블 정규화
    - 외래 키 참조 무경성 제약조건 활용가능
    - 저장공간 효율화
  - 단점
    - 조회시 조인을 많이 사용 -> 성능 저하
    - 조리 쿼리가 복잡
    - 데이터 저장시 Insert SQL 2번 발생 (큰 문제는 되지 않음)
> 서비스가 복잡하고 확장을 염두하고 있을때 사용하면 유용하다.
<img src="/ex1-hello-jpa/img/img-1.png" width="500px;">

- <b>통합 테이블로 변환 -> 단일 테이블 전략</b>
  - 장점
    - 조인이 필요 없다. -> 조회 성능이 빠르다.
    - 조회 쿼리가 단순하다.
  - 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. <br>상황에 따라서 조회 성능이 오히려 늦어질 수 있다. (한계점을 넘으면 발생하는 이슈인데, 한계점을 넘기가 쉽지 않다.)
> 서비스가 단순할때 사용하면 유용하다.

<img src="/ex1-hello-jpa/img/img-2.png" width="500px;">

- <b>서브타입 테이블로 변환 -> 구현 테이블마다 테이블 전략</b>
  - 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    - not null 제약조건 사용 가능
  - 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느리다.(UNION SQL 필요)
    - 자식 테이블을 통합해서 쿼리하기 어렵다.
> 데이터베이스 설계자와 ORM 전문가 모두가 추천하지 않는 전략이다.

<img src="/ex1-hello-jpa/img/img-3.png" width="500px;">

#### 주요 어노테이션
- @Inheritance(strategy = InheritanceType.XXX)
  - JOINED : 조인 전략
  - SINGLE_TABLE : 단일 테이블 전략
  - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 
- @DiscriminatorColumn(name="DTYPE")
- @DiscriminatorValue("XXX")

---
### @MappedSuperclass : 공통 매핑 정보가 필요할 때 사용 
- 상속관계 매핑 X
- 엔티티 X -> 테이블과 매핑 X
- 상속 받는 자식 클래스에 매핑 정보만 제공
- 조회, 검색 불가( em.find(BaseEntity) 불가 )
- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

#### 간단한 정리
- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모우는 역할
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 정보를 모을 때 사용
> 참고 : @Entity 클래스는 @Entity, @MappedSuperclass 로 지정한 클래스만 상속 가능하다.

---
### 8. 프록시와 연관관계 관리
#### 프록시 기초
- em.find() vs em.getReference()
- em.find() : 데이터베이스를 통해서 **실제 엔티티 객체 조회**
- em.getReference() : 데이터베이스 조회를 미루는 **가짜(프록시) 엔티티 객체 조회**

#### 프록시 특징
- 실제 클래스를 **상속** 받아서 만들어 진다. -> 타입 체크시 주의해야 한다.(== 비교 대신 instance of 사용)
- 실제 클래스와 **겉 모양이 같다.**
- **사용하는 입장에서는** 진짜 객체인지 프록시 객체인지 **구분하지 않고 사용**하면 된다.
- 프록시 객체는 실제 객채의 **참조(target)를 보관**
- **프록시 객체를 호출하면** 프록시 객체는 **실제 객체의 메소드 호출**
- 프록시 객체는 **처음 사용할 때 한번만 초기화**한다.
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.<br>초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능하다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면, em.getReference()를 호출해도 실제 엔티티 반환 한다.
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 떼, 프록시를 초기화하면 문제 발생<br>(하이버네이트는 org.hibernate.LazyInitializationException 예외 발)

