### 상속관계 매핑
- 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

#### 슈퍼타입, 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
- 각 테이블로 변환 -> 조인 전략
  - 장점
    - 테이블 정규화
    - 외래 키 참조 무경성 제약조건 활용가능
    - 저장공간 효율화
  - 단점
    - 조회시 조인을 많이 사용 -> 성능 저하
    - 조리 쿼리가 복잡
    - 데이터 저장시 Insert SQL 2번 발생 (큰 문제는 되지 않음)
> 서비스가 복잡하고 확장을 염두하고 있을때 사용하면 유용하다.
<img src="/ex1-hello-jpa/img/img-1.png" width="500px;">

- 통합 테이블로 변환 -> 단일 테이블 전략
  - 장점
    - 조인이 필요 없다. -> 조회 성능이 빠르다.
    - 조회 쿼리가 단순하다.
  - 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. <br>상황에 따라서 조회 성능이 오히려 늦어질 수 있다. (한계점을 넘으면 발생하는 이슈인데, 한계점을 넘기가 쉽지 않다.)
> 서비스가 단순할때 사용하면 유용하다.

<img src="/ex1-hello-jpa/img/img-2.png" width="500px;">

- 서브타입 테이블로 변환 -> 구현 테이블마다 테이블 전략
  - 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    - not null 제약조건 사용 가능
  - 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느리다.(UNION SQL 필요)
    - 자식 테이블을 통합해서 쿼리하기 어렵다.
> 데이터베이스 설계자와 ORM 전문가 모두가 추천하지 않는 전략이다.

<img src="/ex1-hello-jpa/img/img-3.png" width="500px;">

#### 주요 어노테이션
- @Inheritance(strategy = InheritanceType.XXX)
  - JOINED : 조인 전략
  - SINGLE_TABLE : 단일 테이블 전략
  - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
- @DiscriminatorColumn(name="DTYPE")
- @DiscriminatorValue("XXX")
